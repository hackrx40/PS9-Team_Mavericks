#uniformity check
import PyPDF2
from PIL import Image
from fontTools.ttLib import TTFont

def extract_text_from_pdf(pdf_path):
    # Open the PDF file in binary mode
    with open(pdf_path, 'rb') as file:
        pdf_reader = PyPDF2.PdfReader(file)
        text = ""

        # Loop through each page and extract text
        for page_num in range(len(pdf_reader.pages)):
            page = pdf_reader.pages[page_num]
            text += page.extract_text()

    return text

def extract_fonts_from_pdf(pdf_path):
    # Open the PDF file in binary mode
    with open(pdf_path, 'rb') as file:
        pdf_reader = PyPDF2.PdfReader(file)
        fonts = set()

        # Loop through each page and extract font information
        for page_num in range(len(pdf_reader.pages)):
            page = pdf_reader.pages[page_num]
            resources = page['/Resources']
            if '/Font' in resources:
                font_objects = resources['/Font']
                for font_object in font_objects:
                    font_name = font_objects[font_object]['/BaseFont'].decode('utf-8')
                    fonts.add(font_name)

    return fonts

def check_uniformness_of_fonts(file_path):
    if file_path.lower().endswith(".pdf"):
        # If the file is a PDF, extract text using the defined function
        extracted_text = extract_text_from_pdf(file_path)
        fonts_used = extract_fonts_from_pdf(file_path)
    else:
        # If the file is an image, use pytesseract to read the text
        image = Image.open(file_path)
        extracted_text = pytesseract.image_to_string(image)
        fonts_used = set()  # Not applicable for images since fonts aren't used directly in images.

    # Check if only one font is used in the text (uniformness check)
    is_uniform_font = len(fonts_used) == 1

    return is_uniform_font

# Example usage
file_path = "sample.pdf"  # Replace with the path to your PDF or image file
result = check_uniformness_of_fonts(file_path)
print("Uniformness of fonts:", result)


#text pixel
import cv2

def is_text_pixel_changed(image_path, threshold=50):
    # Read the image using OpenCV
    image = cv2.imread(image_path)

    # Convert the image to grayscale
    gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Threshold the image to create a binary image (black and white)
    _, binary_image = cv2.threshold(gray_image, 0, 255, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)

    # Find contours in the binary image
    contours, _ = cv2.findContours(binary_image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # Iterate through each contour
    for contour in contours:
        # Calculate the bounding box of the contour
        x, y, w, h = cv2.boundingRect(contour)

        # Crop the region containing the text from the original image
        text_region = image[y:y+h, x:x+w]

        # Calculate the mean pixel value of the text region
        text_mean_pixel = text_region.mean()

        # Calculate the mean pixel value of the background region
        background_region = image[0:y, 0:x+w]
        background_mean_pixel = background_region.mean()

        # Check if the mean pixel value of the text region is significantly different from the background
        if abs(text_mean_pixel - background_mean_pixel) > threshold:
            return True

    return False

# Example usage
image_path = "PO -3.jpg"  # Replace with the path to your image file
result = is_text_pixel_changed(image_path)
print("Is there a change in text pixel?", result)
